# 高效算法/2 的幂边界

## 将数值上调/下调为 2 的已知次幂的倍数

如果想将无符号整数 x 下调为一个值最接近它同时还是 8 的倍数的数, 那么只需要执行 `x & -8` 就可以了. 如果我们规定"下调"指的是向负无穷方向, 那么这个算法同样适合带符号整数. 上调和下调一样容易, 只需要执行 `(x + 7) & -8`. 上调还有另一个公式 `x + (-x & 7)`, 因此如果你想知道最少给 x 加上几才能把它变成 8 的倍数, 那么用 `-x & 7` 就能算出来.

如果想把一个带符号数朝 0 方向调整为值最接近它且能被 8 整除的数, 那么可以应用下面的算法:

```text
t = (x >> 31) & 7
r = (x + t) & -8
```

一个典型的应用是在 x86 调用约定中, 在发起 call 之前 sp 必须是 16 的倍数(16 byte aligned), 此时可以使用汇编代码:

```text
and rsp, -15
```

## 调整到上一个/下一个 2 的幂

将无符号数 x 下调为不大于 x 且与之最近的 2 的幂

```c
uint32_t flp2(uint32_t x) {
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    return x - (x >> 1);
}
```

上调整为下一个 2 的幂

```c
uint32_t clp2(uint32_t x) {
    x = x - 1;
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    return x + 1;
}
```

## 判断取值范围是否跨越了 2 的幂边界

假定从地址 0 开始将内存划分为大小为 2 的幂的若干块(一个常见的值是 4 KB). 然后, 给定起始地址 a 和长度 l, 我们希望确定地址范围从 a 到 a + l - 1(l >= 2)，是否跨过一个块边界. a 和 l 是无符号整数, 并且可能是任何值. 注意, 当 l 为 0 或 1 时, 永远不会跨越块边界.

这种判断在内存管理方面有很大的作用, 例如按照块来延迟内存的初始化. 假设块的大小是 8, 可以使用如下公式判断:

```text
8 - (a & 7) < l;
```
